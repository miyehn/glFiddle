#version 430

/* each invocation is responsible for updating 1 blade
 * that is, update 16 float entries
 */

layout(local_size_x = 2) in;
uniform vec2 time;

layout(r32f, binding = 0) uniform readonly image1D read_i;
layout(r32f, binding = 1) uniform writeonly image1D write_o;

const float PI = 3.1415926535897932384626433832795;

struct {
  vec3 root;
  vec3 above;
  vec3 ctrl;
  vec3 up;
  float width, height, stiffness, orientation;
} b0, b; // input blade b0, output blade b

float t, dt;

float r(int i) { return imageLoad(read_i, i).x; }

void w(int i, float f) { imageStore(write_o, i, vec4(f, 0, 0, 0)); }

void unpack_input(int i) {
  b0.root = vec3(r(i), r(i+1), r(i+2));
  b0.width = r(i+3);
  b0.above = vec3(r(i+4), r(i+5), r(i+6));
  b0.height = r(i+7);
  b0.ctrl = vec3(r(i+8), r(i+9), r(i+10));
  b0.stiffness = r(i+11);
  b0.up = vec3(r(i+12), r(i+13), r(i+14));
  b0.orientation = r(i+15);
}

void write_output(int i) {
  w(i, b.root.x); w(i+1, b.root.y); w(i+2, b.root.z);
  w(i+3, b.width);
  w(i+4, b.above.x); w(i+5, b.above.y); w(i+6, b.above.z);
  w(i+7, b.height);
  w(i+8, b.ctrl.x); w(i+9, b.ctrl.y); w(i+10, b.ctrl.z);
  w(i+11, b.stiffness);
  w(i+12, b.up.x); w(i+13, b.up.y); w(i+14, b.up.z);
  w(i+15, b.orientation);
}

void main() {
  int start_index = 16 * int(gl_GlobalInvocationID.x);
  unpack_input(start_index);
  t = time.x; dt = time.y;
  //---- above: get input ----

  b.root = b0.root;
  b.above = b0.above;
  b.ctrl = b0.ctrl;
  b.up = b0.up;
  b.width = b0.width;
  b.height = b0.height;
  b.stiffness = b0.stiffness;
  b.orientation = sin(t);

  //---- below: write output ----
  write_output(start_index);
}